trigger:
- master
- stage
- test

variables:
  azureServiceConnection: 'essencif.ai_resources'
  vmImageName: 'ubuntu-latest'
  imageRegistry: 'essencifai-backend'  # Project-specific name
  containerRegistry: 'container-registry'  # Full Azure Container Registry URL
  containerRegistryServerURL: 'essencifaibackendregistry.azurecr.io'  # Full Azure Container server URL
  

stages:
- stage: Build
  displayName: Build and Dockerize
  jobs:
  - job: BuildDockerImage
    pool:
      vmImage: $(vmImageName)
    steps:
    # Login to Azure Container Registry (if needed)
    - task: Docker@2
      displayName: Docker login to ACR
      inputs:
        command: login
        containerRegistry: '$(containerRegistry)'

    - task: Docker@2
      displayName: Build and Push Docker Image
      inputs:
        command: buildAndPush
        containerRegistry: '$(containerRegistry)'
        repository: '$(imageRegistry)'
        dockerfile: '$(Build.SourcesDirectory)/Dockerfile'
        tags: '$(Build.BuildId)'

- stage: DeployTesting
  displayName: 'Deploy Testing'
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/test'))
  variables:
    DEPLOYMENT_APP_SERVICE_CONTAINER: 'essencifai-backend-test'
    AZURE_COMPILATION_ENV: 'testing'
    TEST_APP_URL: 'https://essencifai-backend-test.azurewebsites.net'  # Replace with your actual testing app URL

  jobs:
  - deployment: TestingDeploymentJob
    displayName: 'Deploy to Testing Environment'
    pool:
      vmImage: $(vmImageName)
    environment: 'testing'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: AzureRmWebAppDeployment@4
            inputs:
              ConnectionType: 'AzureRM'
              azureSubscription: $(azureServiceConnection)
              appType: 'webAppContainer'
              WebAppName: $(DEPLOYMENT_APP_SERVICE_CONTAINER)
              containers: $(containerRegistry)/$(imageRegistry):$(Build.BuildId)
              DockerNamespace: 'essencifaibackendregistry.azurecr.io'
              DockerRepository: $(imageRegistry):$(Build.BuildId)

  - job: RunPostDeploymentTests
    displayName: 'Run Post-Deployment Tests'
    dependsOn: TestingDeploymentJob
    pool:
      vmImage: $(vmImageName)
    steps:
    - checkout: self
      
    # Add a delay to ensure the app is fully ready
    - bash: |
        echo "Waiting for application to be fully deployed..."
        sleep 30
      displayName: 'Wait for App to Stabilize'

    # Setup Python environment
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '3.12'
        addToPath: true
      displayName: 'Setup Python 3.12'

    # Install pytest and required dependencies
    - bash: |
        python -m pip install --upgrade pip
        pip install pytest pytest-asyncio httpx python-dotenv
      displayName: 'Install Test Dependencies'

    # Create test environment file
    - bash: |
        echo "BASE_URL=$(TEST_APP_URL)" > $(Build.SourcesDirectory)/tests/.env.test
        echo "VALID_USER_ID=test_valid_user_id" >> $(Build.SourcesDirectory)/tests/.env.test
        echo "INVALID_USER_ID=test_invalid_user_id" >> $(Build.SourcesDirectory)/tests/.env.test
        # Add any other environment variables needed for tests
      displayName: 'Create Test Environment File'
      
    # Run the tests using script.sh
    - bash: |
        chmod +x $(Build.SourcesDirectory)/tests/script.sh
        cd $(Build.SourcesDirectory)/tests
        ./script.sh
      displayName: 'Run Tests using script.sh'
      
    # Alternatively, run pytest directly if needed
    - bash: |
        cd $(Build.SourcesDirectory)/tests
        python -m pytest routes -v --junitxml=test-results.xml
      displayName: 'Run Tests with pytest'
      condition: always()  # Run even if the script.sh execution fails
    
    # Publish test results
    - task: PublishTestResults@2
      displayName: 'Publish Test Results'
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '**/test-results.xml'
        mergeTestResults: true
        testRunTitle: 'Post Deployment Tests'
      condition: succeededOrFailed()
      
    # Archive test results
    - task: CopyFiles@2
      displayName: 'Copy Test Results'
      inputs:
        SourceFolder: '$(Build.SourcesDirectory)/tests/results'
        Contents: '**'
        TargetFolder: '$(Build.ArtifactStagingDirectory)/test-results'
      condition: succeededOrFailed()
      
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Test Results Artifact'
      inputs:
        PathtoPublish: '$(Build.ArtifactStagingDirectory)/test-results'
        ArtifactName: 'test-results'
        publishLocation: 'Container'
      condition: succeededOrFailed()
